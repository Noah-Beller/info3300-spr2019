<html><head>
<title>INFO 3300 - April 12</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>

  #fpsCounter {
    position: fixed;
    bottom: 0;
    right: 0;
    width: 80px;
    height: 30px;
    background-color: #5c5c5c;
    color: #fff;
    text-align: center;
    font-family: Lato, sans-serif;
  }
  #configPanel {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 390px;
    height: 70px;
    padding: 10px;
    border: 1px solid grey;
    background-color: #fff;
    font-family: Lato, sans-serif;
  }



  </style>
</head>

<body>
  <div class="container larger">
  <h3>Notes for April 12</h3>
  <p>Stuff</p>
  <h5>HTML for today:</h5>

  <div id="fpsCounter">FPS</div>
  <div id="configPanel">
    <button id="stop">Stop</button>
    <button id="startSVG">Start SVG</button>
    <button id="startCanvas">Start Canvas</button>
    <div>
      <span>Density:&nbsp;&nbsp;</span>
      <input type="range" min="0.01" max="0.5" step="0.01" id="densitySlider">
      <span id="densityLabel"></span>
    </div>

  </div>
  <p> SVG </p>
  <svg width="769" height="512" class="model">
  </svg>
  <p> Canvas </p>
  <canvas width="769" height="512" class="model"></canvas>

  <h5>Code for today:</h5>
  <pre>
    <code id="display1" class="hljs javascript">
      <!--- autofilled --->
    </code>
  </pre>


  <script id="notes1">

  // Visualize a simple cellular automaton for traffic flow
  // Inspired by Jason Davies example at: https://www.jasondavies.com/bml/#0.14/769/512

  // Configure the random walk
  var width = 769;
  var height = 300;
  var density = 0.22;
  var automaton;
  var timer;
  var useSVG = false;


  function killSimulation() {
    if (timer) { timer.stop(); } // kill existing timer
    d3.selectAll(".layer").html(""); // empty SVG
    let ctx = document.querySelector("canvas.model").getContext("2d");
    ctx.clearRect(0, 0, width, height); // empty canvas

  }
  function restartSimulation() {

    killSimulation();

    // update width/height as need be
    d3.select("canvas.model").attr("width", width).attr("height", height);
    d3.select("svg.model").attr("width", width).attr("height", height);

    automaton = generateBML(width, height, density);

    // render loop with FPS timer
    let fps = d3.select("#fpsCounter").text("");
    var time0 = Date.now();
    var time1 = Date.now();
    timer = d3.timer(function() {

      stepBML(automaton);

      if (useSVG) {
        renderSVG(automaton);
      }
      else {
        renderCanvas(automaton);
      }

      time1 = Date.now();
      fps.text("FPS: " + Math.round(1000 / (time1 - time0)));
      time0 = time1;

    });
  }




  // Use SVG to render the traffic model
  const svg = d3.select("svg.model");
  svg.attr("width", width);
  svg.attr("height", height);
  const downLayer = svg.append("g").attr("class","down layer");
  const rightLayer = svg.append("g").attr("class","right layer");
  const colorScale = d3.scaleOrdinal().domain([0,1,2]).range(["#fff","#3439b9","#c94426"]);

  function renderSVG(bml) {

    let downRects = downLayer.selectAll("rect").data(bml.down);
    downRects.enter().append("rect")
        .attr("width",1)
        .attr("height",1)
        .attr("fill", colorScale(1))
        .merge(downRects) // bring in existing rects and modify all of them
        .attr("x", d => d.x)
        .attr("y", d => d.y);

    let rightRects = rightLayer.selectAll("rect").data(bml.right);
    rightRects.enter().append("rect")
        .attr("width",1)
        .attr("height",1)
        .attr("fill", colorScale(2))
        .merge(rightRects) // bring in existing rects and modify all of them
        .attr("x", d => d.x)
        .attr("y", d => d.y);

  }



  // Use Canvas to render the random walk
  var canvas = document.querySelector("canvas.model"); // select
  canvas.setAttribute("width", width);
  canvas.setAttribute("height", height);
  var context = canvas.getContext("2d"); // fetches the "paintbrush"

  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
  var pixels = imageData.data;
  let downC = d3.rgb(colorScale(1));
  let rightC = d3.rgb(colorScale(2));
  let colorR = [255, downC.r, rightC.r];
  let colorG = [255, downC.g, rightC.g];
  let colorB = [255, downC.b, rightC.b];

  function renderCanvas(bml) {

    // Use JS functions to interact with the canvas and not d3 ones

    // context.clearRect(0, 0, width, height);
    //
    // context.fillStyle = colorScale(1);
    // for (let i = 0; i < bml.down.length; i++) {
    //   let nd = bml.down[i];
    //   context.fillRect( nd.x, nd.y, 1, 1 );
    // }
    //
    // context.fillStyle = colorScale(2);
    // for (let i = 0; i < bml.right.length; i++) {
    //   let nd = bml.right[i];
    //   context.fillRect( nd.x, nd.y, 1, 1 );
    // }

    let grid = bml.grid;

    for(let x = 0; x < width; x++){
        for(y = 0; y < height; y++){
          pixels[4*(y*width + x)+0] = colorR[ grid[y][x] ];
          pixels[4*(y*width + x)+1] = colorG[ grid[y][x] ];
          pixels[4*(y*width + x)+2] = colorB[ grid[y][x] ];
          pixels[4*(y*width + x)+3] = 255;
        }
      }
      context.putImageData(imageData, 0, 0);


  }



  d3.select("#stop").on("click", function() {
    killSimulation();
  });
  d3.select("#startSVG").on("click", function() {
    useSVG = true;
    restartSimulation();
  });
  d3.select("#startCanvas").on("click", function() {
    useSVG = false;
    restartSimulation();
  });

  d3.select("#densityLabel").text(density);
  d3.select("#densitySlider")
    .on("input", function() {
      d3.select("#densityLabel").text(this.value);
      density = this.value
    })
    .on("mouseup", function() {
      if (timer) { // if we are already animating, reset
        restartSimulation();
      }
    });







  // Simulation is a Biham-Middleton-Levine traffic model: https://en.wikipedia.org/wiki/Biham%E2%80%93Middleton%E2%80%93Levine_traffic_model

  // generate and return an initial BML automaton object
  function generateBML(width, height, density) {

    var randType = () => (Math.random() < 0.5) ? 1 : 2; // down or right cell
    let targetCount = width*height*density;

    // initialize and populate
    //  go in reverse order so that node lists are sorted for scanning
    //  use node lists so we don't have to loop through every grid element
    let totalNodes = 0;
    let downNodes = new Array();
    let rightNodes = new Array();
    let grid = new Array(height);
    for (let y = height-1; y  >= 0; y--) {
      grid[y] = new Array(width);
      for (let x = width-1; x >= 0; x--) {
        if (Math.random() > density) { // randomly left empty
          grid[y][x] = 0;
        }
        else { // randomly fill
          let t = randType();
          let obj = {x: x, y: y, type: t};
          grid[y][x] = t;

          if (t === 1) { downNodes.push( obj ); }
          else { rightNodes.push( obj ); }

          totalNodes++;
        }

      }
    }

    return { grid: grid, right: rightNodes, down: downNodes };
  }

  // move a BML automaton one "step" forward
  //  computes downs then rights, O(N)
  function stepBML(bml) {

    let height = bml.grid.length;
    if (height < 1) { return; }
    let width = bml.grid[0].length;

    for (let i = 0; i < bml.down.length; i++) {
      let curY = bml.down[i].y;
      let nextY = (curY + 1) % height;
      let curX = bml.down[i].x;
      // shift down if next spot (toroidally wrapped) is free
      if (bml.grid[nextY][curX] == 0) {
        // console.log('mvY',i,curY, nextY);
        bml.grid[curY][curX] = 0;
        bml.grid[nextY][curX] = bml.down[i].type;
        bml.down[i].y = nextY;
      }
    }
    for (let i = 0; i < bml.right.length; i++) {
      let curX = bml.right[i].x;
      let nextX = (curX + 1) % width;
      let curY = bml.right[i].y;
      // shift right if next spot (toroidally wrapped) is free
      if (bml.grid[curY][nextX] == 0) {
        // console.log('mvX',i,curX, nextX);
        bml.grid[curY][curX] = 0;
        bml.grid[curY][nextX] = bml.right[i].type;
        bml.right[i].x = nextX;
      }
    }

  }







  </script>








  <!--- calls the highlight library to fill the <pre> tag with code --->
  <script>
  document.getElementById("display1").innerText = document.getElementById("notes1").innerText;
  hljs.initHighlightingOnLoad();
  </script>


  </div>
</body>
</html>
